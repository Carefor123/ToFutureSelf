(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{361:function(t,a,e){"use strict";e.r(a);var r=e(1),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("为什么在项目中data需要使用return返回数据呢？")]),t._v(" "),e("h4",{attrs:{id:"众所周知，用组件化来写vue项目时，每个-vue都是一个单独的组件。那什么是vue中的组件呢？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#众所周知，用组件化来写vue项目时，每个-vue都是一个单独的组件。那什么是vue中的组件呢？"}},[t._v("#")]),t._v(" 众所周知，用组件化来写vue项目时，每个.vue都是一个单独的组件。那什么是vue中的组件呢？")]),t._v(" "),e("h4",{attrs:{id:"官网已经介绍得很明白-组件就是一个可复用的vue的实例。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#官网已经介绍得很明白-组件就是一个可复用的vue的实例。"}},[t._v("#")]),t._v(" 官网已经介绍得很明白---组件就是一个可复用的vue的实例。")]),t._v(" "),e("h4",{attrs:{id:"这意味着若你的data是一个普通对象，那么所有复用这个实例的组件都将引用这个data，这样就会造成变量污染。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这意味着若你的data是一个普通对象，那么所有复用这个实例的组件都将引用这个data，这样就会造成变量污染。"}},[t._v("#")]),t._v(" 这意味着若你的data是一个普通对象，那么所有复用这个实例的组件都将引用这个data，这样就会造成变量污染。")]),t._v(" "),e("h4",{attrs:{id:"这时候若将data封装成一个函数，在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了变量污染。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这时候若将data封装成一个函数，在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了变量污染。"}},[t._v("#")]),t._v(" 这时候若将data封装成一个函数，在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了变量污染。")]),t._v(" "),e("h4",{attrs:{id:"总结来说：-不使用return包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结来说：-不使用return包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。"}},[t._v("#")]),t._v(" 总结来说： 不使用return包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);